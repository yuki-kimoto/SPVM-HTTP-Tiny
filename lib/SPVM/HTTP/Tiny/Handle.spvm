# Copyright (c) 2023 Yuki Kimoto
# MIT License

class HTTP::Tiny::Handle {
  version_from HTTP::Tiny;
  
  allow HTTP::Tiny;
  
  use HTTP::Tiny::Message::Request;
  use HTTP::Tiny::Message::Response;
  
  use Fn;
  use StringBuffer;
  use Format;
  use Re;
  use Regex::ReplaceInfo;
  use IO::Socket::INET;
  
  # Enumerations
  private enum {
    READ_BUFFER_SIZE = 4086,
  }
  
  # Fields
  has timeout : double;
  
  has socket : IO::Socket;
  
  has response_buffer : StringBuffer;
  
  private static method new : HTTP::Tiny::Handle ($options : object[]) {
    
    my $options_h = Hash->new($options);
    
    my $self = new HTTP::Tiny::Handle;
    
    # The response_buffer field
    my $res_buffer = StringBuffer->new;
    $self->{response_buffer} = $res_buffer;
    
    # The timeout field
    my $timeout = $options_h->delete_or_default_double("timeout", 60.0);
    $self->{timeout} = $timeout;
    
    return $self;
  }
  
  private method connect : HTTP::Tiny::Handle ($req : HTTP::Tiny::Message::Request) {
    
    my $url = $req->url;
    my $scheme = $url->scheme;
    my $host = $url->host;
    my $port = $url->port;
    
    my $timeout = $self->{timeout};
    
    my $socket = (IO::Socket)undef;
    
    if ($scheme eq "http") {
      $socket = IO::Socket::INET->new({
        PeerAddr  => $host,
        PeerPort  => $port,
        Timeout   => $timeout,
      });
    }
    elsif ($scheme eq "https") {
      if (require IO::Socket::SSL) {
        $socket = IO::Socket::SSL->new({
          PeerAddr  => $host,
          PeerPort  => $port,
          Timeout   => $timeout,
        });
      }
      else {
        die "IO::Socket::SSL is required for HTTPS access.";
      }
    }
    else {
      die "The scheme $scheme is not supported.";
    }
    
    $self->{socket} = $socket;
    
    return $self;
  }
  
  private method write_request : void ($req : HTTP::Tiny::Message::Request) {
    
    $self->write_request_line($req);
    
    $self->write_request_headers($req);
    
    $self->write("\r\n");
  }
  
  private method write_request_line : void ($req : HTTP::Tiny::Message::Request) {
    
    my $start_line = $req->build_start_line;
    
    $self->write($start_line);
  }
  
  private method write_request_headers : void ($req : HTTP::Tiny::Message::Request) {
    
    my $header_lines = $req->build_headers;
    
    $self->write($header_lines);
  }
  
  private method write : void ($buffer : string) {
    
    my $socket = $self->{socket};
    
    $socket->write($buffer);
  }
  
  private method read_response : HTTP::Tiny::Message::Response () {
    
    my $res = HTTP::Tiny::Message::Response->new;
    
    my $handle = $self->{socket};
    
    while (1) {
      my $chunk = (mutable string)new_string_len &READ_BUFFER_SIZE;
      
      my $read_length = $handle->read($chunk);
      
      if ($read_length == 0) {
        $res->finish;
        last;
      }
      
      Fn->shorten($chunk, $read_length);
      
      $res->parse($chunk);
      
      if ($res->is_finished) {
        last;
      }
    }
    
    return $res;
  }
  
  method _find_CA_file : int () {
    return 0;
  }
}
