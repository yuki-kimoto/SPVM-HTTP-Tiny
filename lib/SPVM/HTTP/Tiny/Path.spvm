# Copyright (c) 2025 Yuki Kimoto
# MIT License

class HTTP::Tiny::Path {
  version_from HTTP::Tiny;
  
  # Fields
  has path : string;
  
  has parts_list : StringList;
  
  has leading_slash : byte;
  
  has trailing_slash : byte;
  
  # Class Methods
  static method new : HTTP::Tiny::Path ($path_string : string = undef) {
    
    my $self = new HTTP::Tiny::Path;
    
    if ($path_string) {
      $self->parse($path_string);
    }
    
    return $self;
  }

=pod

  method canonicalize {
    
    my $parts = $self->parts;
    
    my $parts_length = @$parts;
    
    my $parts_list = StringList->new($parts);
    
    my $i = 0;
    while ($i < $parts_length) {
      
      my $part = $parts->[$i];
      
      my $part_length = length $part;
      
      if ($part_length == 0 || $part eq "." || $part eq "...") {
        
      }
      
      if    (!length $parts->[$i] || $parts->[$i] eq '.' || $parts->[$i] eq '...') {
        splice @$parts, $i, 1
      }
      elsif ($i < 1 || $parts->[$i] ne '..' || $parts->[$i - 1] eq '..')           {
        $i++
      }
      else                                                                         {
        splice @$parts, --$i, 2
      }
    }
    
    return @$parts ? $self : $self->trailing_slash(undef);
  }

=cut

  method parse : void ($path : string) {
    
    # This method does not parse $path, parts method parse path field by calling _parse method.
    $self->{path} = $path;
    $self->{parts_list} = undef;
  }
  
  method to_string : string () {
    # Path
    if (my $path = $self->{path}) {
      return &url_escape($path, "^A-Za-z0-9\-._~!\$&\'()*+,;=%:@/");
    }
    
    # Build path
    my $parts = $self->parts;
    
    my $path = Fn->join("/", (string[])Fn->map($parts, method : object ($part : object) { return &url_escape((string)$part, "^A-Za-z0-9\-._~!\$&\'()*+,;=:@"); }));
    
    if ($self->leading_slash) {
      $path = "/$path";
    }
    
    if ($self->trailing_slash) {
      $path = "$path/";
    }
    
    return $path;
  }
  
  method to_abs_string : string () {
    
    my $abs_path = $self->to_string;
    
    unless (Re->m($abs_path, "^/")) {
      $abs_path = "/$abs_path";
    }
    
    return $abs_path;
  }
  
  method leading_slash : int () {
    $self->_parse;
    return $self->{leading_slash};
  }
  
  method set_leading_slash : void ($bool : int) {
    $self->_parse;
    $self->{leading_slash} = (byte)$bool;
  }
  
  method trailing_slash : int () {
    $self->_parse;
    return $self->{trailing_slash};
  }
  
  method set_trailing_slash : void ($bool : int) {
    $self->_parse;
    $self->{trailing_slash} = (byte)$bool;
  }
  
  method parts : string[] () {
    $self->_parse;
    return $self->{parts_list}->to_array;
  }
  
  method set_parts : void ($parts : string[]) {
    $self->_parse;
    $self->{parts_list} = StringList->new($parts);
  }
  
  private method _parse : void (){
    
    my $parts_list = $self->{parts_list};
    
    unless ($parts_list) {
      my $path_url_encoded = $self->{path};
      $self->{path} = undef;
      unless ($path_url_encoded) {
        $path_url_encoded = "";
      }
      my $path = &url_unescape($path_url_encoded);
      $self->{leading_slash} = (byte)!!Re->s($path, "^/", "");
      $self->{trailing_slash} = (byte)!!Re->s($path, "/$", "");
      $self->{parts_list} = StringList->new(Fn->split("/", $path, -1));
    }
    
  }
  
  # TODO
  private static method url_escape : string ($string : string, $pattern : string) {
    
    return undef;
  }
  
  # TODO
  private static method url_unescape : string ($string : string) {
    
    return undef;
  }
  
  method contains : int ($string : string) {
    
    unless ($string) {
      die "The string \$string must be defined.";
    }
    
    my $contains = 0;
    if ($string eq "/") {
      $contains = 1;
    }
    else {
      if (Fn->contains($self->to_route, $string)) {
        $contains = 1;
      }
    }
    
    return $contains;
  }
  
  method to_route : string () {
    
    my $clone = $self->clone;
    
    my $route = "/";
    
    $route .= Fn->join("/", $clone->parts);
    
    if ($clone->trailing_slash) {
      $route .= "/";
    }
    
    return $route;
  }
  
  method clone : HTTP::Tiny::Path () {
    
    my $clone = HTTP::Tiny::Path->new;
    
    if (my $parts_list = $self->{parts_list}) {
      $clone->{leading_slash} = $self->{leading_slash};
      $clone->{trailing_slash} = $self->{trailing_slash};
      
      $clone->{parts_list} = StringList->new($parts_list->to_array);
    }
    else {
      $clone->{path} = copy $self->{path};
    }
    
    return $clone;
  }
  
  method merge : void ($path : object of string|HTTP::Tiny::Path) {
    
    unless ($path) {
      die "The path \$path must be defined.";
    }
    
    my $path_string = (string)undef;
    if ($path isa string) {
      # Do nothing
    }
    elsif ($path isa HTTP::Tiny::Path) {
      $path_string = $path->(HTTP::Tiny::Path)->to_string;
    }
    else {
      die "Tha type of the path \$path must be string or HTTP::Tiny::Path.";
    }
    
    if (Re->m($path_string, "^/")) {
      $self->parse($path_string);
      return;
    }
    
    # Merge
    unless ($self->trailing_slash) {
      $self->{parts_list}->pop;
    }
    
    my $path_obj = HTTP::Tiny::Path->new($path_string);
    
    for my $part (@{$path_obj->parts}) {
      $self->{parts_list}->push($part);
    }
    
    $self->set_trailing_slash($path_obj->trailing_slash);
  }

}

__END__


sub clone {
  my $self = shift;

  my $clone = $self->new;
  if (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
  if (my $parts = $self->{parts}) {
    $clone->{$_} = $self->{$_} for qw(leading_slash trailing_slash);
    $clone->{parts} = [@$parts];
  }
  else { $clone->{path} = $self->{path} }

  return $clone;
}

sub contains { $_[1] eq '/' || $_[0]->to_route =~ m!^\Q$_[1]\E(?:/|$)! }

sub leading_slash { shift->_parse(leading_slash => @_) }

sub merge {
  my ($self, $path) = @_;

  # Replace
  return $self->parse($path) if $path =~ m!^/!;

  # Merge
  pop @{$self->parts} unless $self->trailing_slash;
  $path = $self->new($path);
  push @{$self->parts}, @{$path->parts};
  return $self->trailing_slash($path->trailing_slash);
}

sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }

sub parse {
  my $self = shift;
  $self->{path} = shift;
  delete @$self{qw(leading_slash parts trailing_slash)};
  return $self;
}

sub parts { shift->_parse(parts => @_) }

sub to_abs_string {
  my $path = shift->to_string;
  return $path =~ m!^/! ? $path : "/$path";
}

sub to_dir {
  my $clone = shift->clone;
  pop @{$clone->parts} unless $clone->trailing_slash;
  return $clone->trailing_slash(!!@{$clone->parts});
}

sub to_route {
  my $clone = shift->clone;
  return '/' . join '/', @{$clone->parts}, $clone->trailing_slash ? '' : ();
}

sub to_string {
  my $self = shift;

  # Path
  my $charset = $self->charset;
  if (defined(my $path = $self->{path})) {
    $path = encode $charset, $path if $charset;
    return url_escape $path, '^A-Za-z0-9\-._~!$&\'()*+,;=%:@/';
  }

  # Build path
  my @parts = @{$self->parts};
  @parts = map { encode $charset, $_ } @parts if $charset;
  my $path = join '/', map { url_escape $_, '^A-Za-z0-9\-._~!$&\'()*+,;=:@' } @parts;
  $path = "/$path" if $self->leading_slash;
  $path = "$path/" if $self->trailing_slash;
  return $path;
}

sub trailing_slash { shift->_parse(trailing_slash => @_) }

sub _parse {
  my ($self, $name) = (shift, shift);

  unless ($self->{parts}) {
    my $path    = url_unescape delete($self->{path}) // '';
    my $charset = $self->charset;
    $path                   = decode($charset, $path) // $path if $charset;
    $self->{leading_slash}  = $path =~ s!^/!!;
    $self->{trailing_slash} = $path =~ s!/$!!;
    $self->{parts}          = [split /\//, $path, -1];
  }

  return $self->{$name} unless @_;
  $self->{$name} = shift;
  return $self;
}

sub url_escape {
  my ($str, $pattern) = @_;

  if ($pattern) {
    unless (exists $PATTERN{$pattern}) {
      (my $quoted = $pattern) =~ s!([/\$\[])!\\$1!g;
      $PATTERN{$pattern} = eval "sub { \$_[0] =~ s/([$quoted])/sprintf '%%%02X', ord \$1/ge }" or croak $@;
    }
    $PATTERN{$pattern}->($str);
  }
  else { $str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge }

  return $str;
}

sub url_unescape {
  my $str = shift;
  $str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;
  return $str;
}

1;
