# Copyright (c) 2025 Yuki Kimoto
# MIT License

class HTTP::Tiny::Util {
  version_from HTTP::Tiny;
  
  use Re;
  
  static method url_escape : string ($str : string, $pattern : string) {
    
  }
  
  static method url_unescape : string ($string : string) {
    
    unless ($string) {
      die "The string \$string muse be defined.";
    }
    
    my $string_ref = [$string];
    Re->s($string_ref, ["%([0-9a-fA-F]{2})", "g"], method : string ($regex : Regex, $match : Regex::Match) {
      
      my $ret = Fn->chr(Fn->hex($match->cap1));
      
      return $ret;
    });
    
    return $string_ref->[0];
  }
  
}

__END__

TODO

sub url_escape {
  my ($str, $pattern) = @_;

  if ($pattern) {
    unless (exists $PATTERN{$pattern}) {
      (my $quoted = $pattern) =~ s!([/\$\[])!\\$1!g;
      $PATTERN{$pattern} = eval "sub { \$_[0] =~ s/([$quoted])/sprintf '%%%02X', ord \$1/ge }" or croak $@;
    }
    $PATTERN{$pattern}->($str);
  }
  else { $str =~ s/([^A-Za-z0-9\-._~])/sprintf '%%%02X', ord $1/ge }

  return $str;
}

sub url_unescape {
  my $str = shift;
  $str =~ s/%([0-9a-fA-F]{2})/chr hex $1/ge;
  return $str;
}
