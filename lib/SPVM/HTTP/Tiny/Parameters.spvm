# Copyright (c) 2025 Yuki Kimoto
# MIT License

class HTTP::Tiny::Parameters {
  version_from HTTP::Tiny;
  
  use HTTP::Tiny::Util;
  use Hash;
  use Sort;
  
  # Fields
  has string : string;
  
  has pairs_list : StringList;
  
  # Class Methods
  static method new : HTTP::Tiny::Parameters ($string : string = undef) {
    
    my $self = new HTTP::Tiny::Parameters;
    
    if ($string) {
      $self->parse($string);
    }
    
    return $self;
  }
  
  # Instance Methods
  method append : void ($pairs : object of object[]|HTTP::Tiny::Parameters) {
    
    unless ($pairs) {
      die "The pairs \$pairs must be defined.";
    }
    
    my $pairs_array = (object[])undef;
    if ($pairs isa object[]) {
      $pairs_array = (object[])$pairs;
    }
    elsif ($pairs isa HTTP::Tiny::Parameters) {
      $pairs_array = $pairs->(HTTP::Tiny::Parameters)->pairs;
    }
    else {
      die "The type of \$pairs must be object[] or HTTP::Tiny::Parameters.";
    }
    
    my $pairs_array_length = @$pairs_array;
    
    unless ($pairs_array_length % 2 == 0) {
      die "The length of \$pairs must be an even number if it is an array.";
    }
    
    my $old_list = $self->{pairs_list};
    
    my $new = $pairs_array;
    
    for (my $i = 0; $i < @$new; $i += 2) {
      my $new_name = $new->[0];
      my $new_value = $new->[1];
      
      if ($new_value) {
        if ($new_value isa string) {
          $old_list->push((string)$new_name);
          $old_list->push((string)$new_value);
        }
        elsif ($new_value isa string[]) {
          for my $one_new_value (@(string[])$new_value) {
            $old_list->push((string)$new_name);
            $old_list->push($one_new_value);
          }
        }
        else {
          die "The type of the value \$pairs->[$i] must be string or string[].";
        }
      }
    }
    
  }
  
  method clone : HTTP::Tiny::Parameters () {
    
    my $clone = HTTP::Tiny::Parameters->new;
    
    if ($self->{string}) {
      $clone->{string} = copy $self->{string};
    }
    else {
      $clone->{pairs_list} = StringList->new(Array->copy_string($self->pairs));
    }
    
    return $clone;
  }
  
  method every_param : string[] ($name : string) {
    
    my $values_list = StringList->new;
    
    my $pairs_list = StringList->new($self->pairs);
    
    for (my $i = 0; $i < $pairs_list->length; $i += 2) {
      if ($pairs_list->get($i) eq $name) {
        $values_list->push($pairs_list->get($i + 1));
      }
    }
    
    my $values = $values_list->to_array;
    
    return $values;
  }
  
  method merge : void ($parameters : object of object[]|HTTP::Tiny::Parameters)  {
    
    unless ($parameters) {
      die "The parameters \$parameters must be defined.";
    }
    
    my $parameters_hash = (Hash)undef;
    if ($parameters isa object[]) {
      $parameters_hash = Hash->new((object[])$parameters);
    }
    elsif ($parameters isa HTTP::Tiny::Parameters) {
      $parameters_hash = $parameters->(HTTP::Tiny::Parameters)->to_hash;
    }
    else {
      die "The type of the parameters \$parameters must be object[] or HTTP::Tiny::Parameters.";
    }
    
    my $merge = $parameters_hash;
    my $merge_keys = $merge->keys;
    Sort->sort_string_asc($merge_keys);
    
    for my $name (@$merge_keys) {
      my $value = $merge->get($name);
      if ($value) {
        $self->set_param($name => $value);
      }
      else {
        $self->remove($name);
      }
    }
    
  }
  
  method names : string[] () {
    
    my $hash = $self->to_hash;
    my $keys = $hash->keys;
    Sort->sort_string_asc($keys);
    
    return $keys;
  }
  
  method pairs : string[] () {
    
    $self->_parse;
    
    return $self->{pairs_list}->to_array;
  }
  
  method _parse : void () {
    
    my $string = $self->{string};
    $self->{string} = undef;
    
    $self->{pairs_list} = StringList->new;
    
    my $pairs_list = $self->{pairs_list};
    
    if (length $string) {
      for my $pair (@{Fn->split("&", $string)}) {
        if (my $match = Re->m($pair, "^([^=]+)(?:=(.*))?$")) {
          my $name = $match->cap1;
          my $value = $match->cap2;
          
          my $name_ref = [$name];
          Re->s($name_ref, ["\+", "g"], " ");
          $name = $name_ref->[0];
          
          my $value_ref = [$value];
          Re->s($value_ref, ["\+", "g"], " ");
          $value = $value_ref->[0];
          unless ($value) {
            $value = "";
          }
          
          $name  = HTTP::Tiny::Util->url_unescape($name);
          $value = HTTP::Tiny::Util->url_unescape($value);
          
          $pairs_list->push($name);
          $pairs_list->push($value);
        }
      }
    }
    
  }
  
  method set_pairs : void ($pairs : string[])  {
    
    unless ($pairs) {
      die "The paris \$pairs must be defined.";
    }
    
    $self->{pairs_list} = StringList->new($pairs);
    
    $self->{string} = undef;
    
  }

  method param : string ($name : string) {
    
    my $every_param = $self->every_param($name);
    
    my $param = (string)undef;
    if (@$every_param) {
      $param = $every_param->[0];
    }
    
    return $param;
  }
  
  method set_param : void ($name : string, $value : object of string|string[]) {
    
    unless ($name) {
      die "The name \$name must be defined.";
    }
    
    unless ($value) {
      die "The value \$value must be defined.";
    }
    
    $self->remove($name);
    
    if ($value isa string) {
      $self->append([(string)$value]);
    }
    elsif ($value isa string[]) {
      $self->append((string[])$value);
    }
    else {
      die "The type of value \$value must be string or string[].";
    }
    
  }
  
  method remove : void ($name : string) {
    
    unless ($name) {
      die "The name \$name must be defined.";
    }
    
    $self->_parse;
    
    my $pairs_list = $self->{pairs_list};
    
    my $i     = 0;
    while ($i < $pairs_list->length) {
      if ($pairs_list->get($i) eq $name) {
        $pairs_list->remove($i);
        $pairs_list->remove($i + 1);
      }
      else {
        $i += 2;
      }
    }
    
  }
  
  method to_hash : Hash () {
    
  }
  
  method parse : void ($string : string) {
    
    $self->{string} = $string;
    
  }
  
}

__END__

TODO

package Mojo::Parameters;
use Mojo::Base -base;
use overload '@{}' => sub { shift->pairs }, bool => sub {1}, '""' => sub { shift->to_string }, fallback => 1;

use Mojo::Util qw(decode encode url_escape url_unescape);

has charset => 'UTF-8';

sub append {
  my $self = shift;

  my $old = $self->pairs;
  my @new = @_ == 1 ? @{shift->pairs} : @_;
  while (my ($name, $value) = splice @new, 0, 2) {

    # Multiple values
    if (ref $value eq 'ARRAY') { push @$old, $name => $_ // '' for @$value }

    # Single value
    elsif (defined $value) { push @$old, $name => $value }
  }

  return $self;
}

sub clone {
  my $self = shift;

  my $clone = $self->new;
  if   (exists $self->{charset}) { $clone->{charset} = $self->{charset} }
  if   (defined $self->{string}) { $clone->{string}  = $self->{string} }
  else                           { $clone->{pairs}   = [@{$self->pairs}] }

  return $clone;
}

sub every_param {
  my ($self, $name) = @_;

  my @values;
  my $pairs = $self->pairs;
  for (my $i = 0; $i < @$pairs; $i += 2) {
    push @values, $pairs->[$i + 1] if $pairs->[$i] eq $name;
  }

  return \@values;
}

sub merge {
  my $self = shift;

  my $merge = @_ == 1 ? shift->to_hash : {@_};
  for my $name (sort keys %$merge) {
    my $value = $merge->{$name};
    defined $value ? $self->param($name => $value) : $self->remove($name);
  }

  return $self;
}

sub names { [sort keys %{shift->to_hash}] }

sub new { @_ > 1 ? shift->SUPER::new->parse(@_) : shift->SUPER::new }

sub pairs {
  my $self = shift;

  # Replace parameters
  if (@_) {
    $self->{pairs} = shift;
    delete $self->{string};
    return $self;
  }

  # Parse string
  if (defined(my $str = delete $self->{string})) {
    my $pairs = $self->{pairs} = [];
    return $pairs unless length $str;

    my $charset = $self->charset;
    for my $pair (split /&/, $str) {
      next unless $pair =~ /^([^=]+)(?:=(.*))?$/;
      my ($name, $value) = ($1, $2 // '');

      # Replace "+" with whitespace, unescape and decode
      s/\+/ /g for $name, $value;
      $name  = url_unescape $name;
      $name  = decode($charset, $name) // $name if $charset;
      $value = url_unescape $value;
      $value = decode($charset, $value) // $value if $charset;

      push @$pairs, $name, $value;
    }
  }

  return $self->{pairs} //= [];
}

sub param {
  my ($self, $name) = (shift, shift);
  return $self->every_param($name)->[-1] unless @_;
  $self->remove($name);
  return $self->append($name => ref $_[0] eq 'ARRAY' ? $_[0] : [@_]);
}

sub parse {
  my $self = shift;

  # Pairs
  return $self->append(@_) if @_ > 1;

  # String
  $self->{string} = shift;
  return $self;
}

sub remove {
  my ($self, $name) = @_;
  my $pairs = $self->pairs;
  my $i     = 0;
  $pairs->[$i] eq $name ? splice @$pairs, $i, 2 : ($i += 2) while $i < @$pairs;
  return $self;
}

sub to_hash {
  my $self = shift;

  my %hash;
  my $pairs = $self->pairs;
  for (my $i = 0; $i < @$pairs; $i += 2) {
    my ($name, $value) = @{$pairs}[$i, $i + 1];

    # Array
    if (exists $hash{$name}) {
      $hash{$name} = [$hash{$name}] if ref $hash{$name} ne 'ARRAY';
      push @{$hash{$name}}, $value;
    }

    # String
    else { $hash{$name} = $value }
  }

  return \%hash;
}

sub to_string {
  my $self = shift;

  # String (RFC 3986)
  my $charset = $self->charset;
  if (defined(my $str = $self->{string})) {
    $str = encode $charset, $str if $charset;
    return url_escape $str, '^A-Za-z0-9\-._~%!$&\'()*+,;=:@/?';
  }

  # Build pairs (HTML Living Standard)
  my $pairs = $self->pairs;
  return '' unless @$pairs;
  my @pairs;
  for (my $i = 0; $i < @$pairs; $i += 2) {
    my ($name, $value) = @{$pairs}[$i, $i + 1];

    # Escape and replace whitespace with "+"
    $name  = encode $charset,   $name if $charset;
    $name  = url_escape $name,  '^*\-.0-9A-Z_a-z';
    $value = encode $charset,   $value if $charset;
    $value = url_escape $value, '^*\-.0-9A-Z_a-z';
    s/\%20/\+/g for $name, $value;

    push @pairs, "$name=$value";
  }

  return join '&', @pairs;
}

1;

=encoding utf8

=head1 NAME

Mojo::Parameters - Parameters

=head1 SYNOPSIS

  use Mojo::Parameters;

  # Parse
  my $params = Mojo::Parameters->new('foo=bar&baz=23');
  say $params->param('baz');

  # Build
  my $params = Mojo::Parameters->new(foo => 'bar', baz => 23);
  push @$params, i => '♥ mojolicious';
  say "$params";

=head1 DESCRIPTION

L<Mojo::Parameters> is a container for form parameters used by L<Mojo::URL>, based on L<RFC
3986|https://tools.ietf.org/html/rfc3986> and the L<HTML Living Standard|https://html.spec.whatwg.org>.

=head1 ATTRIBUTES

L<Mojo::Parameters> implements the following attributes.

=head2 charset

  my $charset = $params->charset;
  $params     = $params->charset('UTF-8');

Charset used for encoding and decoding parameters, defaults to C<UTF-8>.

  # Disable encoding and decoding
  $params->charset(undef);

=head1 METHODS

L<Mojo::Parameters> inherits all methods from L<Mojo::Base> and implements the following new ones.

=head2 append

  $params = $params->append(foo => 'ba&r');
  $params = $params->append(foo => ['ba&r', 'baz']);
  $params = $params->append(foo => ['bar', 'baz'], bar => 23);
  $params = $params->append(Mojo::Parameters->new);

Append parameters. Note that this method will normalize the parameters.

  # "foo=bar&foo=baz"
  Mojo::Parameters->new('foo=bar')->append(Mojo::Parameters->new('foo=baz'));

  # "foo=bar&foo=baz"
  Mojo::Parameters->new('foo=bar')->append(foo => 'baz');

  # "foo=bar&foo=baz&foo=yada"
  Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada']);

  # "foo=bar&foo=baz&foo=yada&bar=23"
  Mojo::Parameters->new('foo=bar')->append(foo => ['baz', 'yada'], bar => 23);

=head2 clone

  my $params2 = $params->clone;

Return a new L<Mojo::Parameters> object cloned from these parameters.

=head2 every_param

  my $values = $params->every_param('foo');

Similar to L</"param">, but returns all values sharing the same name as an array reference. Note that this method will
normalize the parameters.

  # Get first value
  say $params->every_param('foo')->[0];

=head2 merge

  $params = $params->merge(foo => 'ba&r');
  $params = $params->merge(foo => ['ba&r', 'baz']);
  $params = $params->merge(foo => ['bar', 'baz'], bar => 23);
  $params = $params->merge(Mojo::Parameters->new);

Merge parameters. Note that this method will normalize the parameters.

  # "foo=baz"
  Mojo::Parameters->new('foo=bar')->merge(Mojo::Parameters->new('foo=baz'));

  # "yada=yada&foo=baz"
  Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => 'baz');

  # "yada=yada"
  Mojo::Parameters->new('foo=bar&yada=yada')->merge(foo => undef);

=head2 names

  my $names = $params->names;

Return an array reference with all parameter names.

  # Names of all parameters
  say for @{$params->names};

=head2 new

  my $params = Mojo::Parameters->new;
  my $params = Mojo::Parameters->new('foo=b%3Bar&baz=23');
  my $params = Mojo::Parameters->new(foo => 'b&ar');
  my $params = Mojo::Parameters->new(foo => ['ba&r', 'baz']);
  my $params = Mojo::Parameters->new(foo => ['bar', 'baz'], bar => 23);

Construct a new L<Mojo::Parameters> object and L</"parse"> parameters if necessary.

=head2 pairs

  my $array = $params->pairs;
  $params   = $params->pairs([foo => 'b&ar', baz => 23]);

Parsed parameter pairs. Note that this method will normalize the parameters.

  # Remove all parameters
  $params->pairs([]);

=head2 param

  my $value = $params->param('foo');
  $params   = $params->param(foo => 'ba&r');
  $params   = $params->param(foo => qw(ba&r baz));
  $params   = $params->param(foo => ['ba;r', 'baz']);

Access parameter values. If there are multiple values sharing the same name, and you want to access more than just the
last one, you can use L</"every_param">. Note that this method will normalize the parameters.

=head2 parse

  $params = $params->parse('foo=b%3Bar&baz=23');

Parse parameters.

=head2 remove

  $params = $params->remove('foo');

Remove parameters. Note that this method will normalize the parameters.

  # "bar=yada"
  Mojo::Parameters->new('foo=bar&foo=baz&bar=yada')->remove('foo');

=head2 to_hash

  my $hash = $params->to_hash;

Turn parameters into a hash reference. Note that this method will normalize the parameters.

  # "baz"
  Mojo::Parameters->new('foo=bar&foo=baz')->to_hash->{foo}[1];

=head2 to_string

  my $str = $params->to_string;

Turn parameters into a string.

  # "foo=bar&baz=23"
  Mojo::Parameters->new->pairs([foo => 'bar', baz => 23])->to_string;

=head1 OPERATORS

L<Mojo::Parameters> overloads the following operators.

=head2 array

  my @pairs = @$params;

Alias for L</"pairs">. Note that this will normalize the parameters.

  say $params->[0];
  say for @$params;

=head2 bool

  my $bool = !!$params;

Always true.

=head2 stringify

  my $str = "$params";

Alias for L</"to_string">.

=head1 SEE ALSO

L<Mojolicious>, L<Mojolicious::Guides>, L<https://mojolicious.org>.

=cut
