# Copyright (c) 2026 Yuki Kimoto
# MIT License

class HTTP::Tiny {
  version "0.016";
  
  use Fn;
  use Hash;
  use Mojo::UserAgent;
  use Mojo::Headers;
  use Mojo::URL;
  use Mojo::Date;
  use Go::Context;
  use HTTP::Tiny::Response;
  use File::Temp;
  use IO::File;
  use Sys;

  # Fields
  has ua : rw Mojo::UserAgent;
  has max_redirect : rw int;
  
  # Class Methods
  static method new : HTTP::Tiny ($options : object[] = undef) {
    
    my $self = new HTTP::Tiny;
    my $options_h = Hash->new($options);
    
    my $ua = Mojo::UserAgent->new;
    
    # Set custom User-Agent
    my $agent = (string)$options_h->get_or_default("agent", undef);
    if ($agent) {
      $ua->transactor->set_name($agent);
    } else {
      $ua->transactor->set_name($self->create_default_agent);
    }
    
    # Configure inactivity timeout
    my $inactivity_timeout = $options_h->get_or_default("inactivity_timeout", 60.0)->(double);
    $ua->set_inactivity_timeout($inactivity_timeout);
    
    # Configure SSL verification
    my $verify_SSL = $options_h->get_or_default("verify_SSL", (byte)0)->(byte);
    $ua->set_insecure($verify_SSL ? (byte)0 : (byte)1);
    
    # SSL_options: set_tls_options needs object[] via to_options
    my $ssl_options = $options_h->get_or_default("SSL_options", undef);
    if ($ssl_options) {
      $ua->set_tls_options(Hash->new((object[])$ssl_options)->to_options);
    }
    
    $self->{ua} = $ua;
    $self->{max_redirect} = $options_h->get_or_default("max_redirect", 5)->(int);
    
    return $self;
  }

  # Instance Methods
  method get : HTTP::Tiny::Response ($ctx : Go::Context, $url : string, $options : object[] = undef) {
    return $self->request($ctx, "GET", $url, $options);
  }

  method head : HTTP::Tiny::Response ($ctx : Go::Context, $url : string, $options : object[] = undef) {
    return $self->request($ctx, "HEAD", $url, $options);
  }

  method put : HTTP::Tiny::Response ($ctx : Go::Context, $url : string, $options : object[] = undef) {
    return $self->request($ctx, "PUT", $url, $options);
  }

  method post : HTTP::Tiny::Response ($ctx : Go::Context, $url : string, $options : object[] = undef) {
    return $self->request($ctx, "POST", $url, $options);
  }

  method patch : HTTP::Tiny::Response ($ctx : Go::Context, $url : string, $options : object[] = undef) {
    return $self->request($ctx, "PATCH", $url, $options);
  }

  method delete : HTTP::Tiny::Response ($ctx : Go::Context, $url : string, $options : object[] = undef) {
    return $self->request($ctx, "DELETE", $url, $options);
  }

  method post_form : HTTP::Tiny::Response ($ctx : Go::Context, $url : string, $data : object[], $options : object[] = undef) {
    my $options_h = Hash->new($options);
    $options_h->set(form => $data);
    return $self->request($ctx, "POST", $url, $options_h->to_array);
  }

  method mirror : HTTP::Tiny::Response ($ctx : Go::Context, $url : string, $file : string, $options : object[] = undef) {
    unless ($file) { die "\$file must be defined."; }

    my $options_h = Hash->new($options);
    my $headers = (Mojo::Headers)$options_h->get_or_default("headers", Mojo::Headers->new);

    if (Sys->e($file)) {
      my $mtime = Sys->stat($file)->st_mtime;
      unless ($headers->if_modified_since) {
        $headers->set_if_modified_since(Mojo::Date->new($mtime)->to_string);
      }
    }

    my $tmp_dir = File::Temp->newdir;
    my $tempfile = $tmp_dir->dirname . "/mirror";
    
    my $tx = $self->{ua}->build_tx("GET", $url);
    
    # Use from_hash with Hash object
    if (@{$headers->names} > 0) {
      $tx->req->headers->from_hash($headers->to_hash);
    }
    
    $self->{ua}->start($ctx, $tx);
    my $res = $tx->res;

    if ($res->is_success) {
      my $io_file = IO::File->new($tempfile, ">");
      $io_file->print($res->body);
      $io_file->close;
      
      Sys->rename($tempfile, $file);
      
      my $lm = $res->headers->last_modified;
      if ($lm) {
        my $mtime = Mojo::Date->new($lm)->epoch_sec;
        Sys->utime($mtime, $mtime, $file);
      }
    }

    return HTTP::Tiny::Response->new($res);
  }

  private method request : HTTP::Tiny::Response ($ctx : Go::Context, $method : string, $url : string, $options : object[]) {
    my $options_h = Hash->new($options);
    
    my $headers_opt = (Mojo::Headers)$options_h->get_or_default("headers", undef);
    my $content     = (string)$options_h->get_or_default("content", undef);
    my $form        = (object[])$options_h->get_or_default("form", undef);
    
    my $tx = (Mojo::Transaction::HTTP)undef;
    if ($form) {
      $tx = $self->{ua}->build_tx($method, $url, form => $form);
    } else {
      $tx = $self->{ua}->build_tx($method, $url, $content);
    }

    # Use from_hash with Hash object
    if ($headers_opt) {
      $tx->req->headers->from_hash($headers_opt->to_hash);
    }

    $self->{ua}->set_max_redirects($self->{max_redirect});
    $tx = $self->{ua}->start($ctx, $tx);

    return HTTP::Tiny::Response->new($tx->res);
  }

  method create_default_agent : string () {
    my $version = Fn->get_version_string("HTTP::Tiny");
    return "SPVM/HTTP::Tiny/$version";
  }
}